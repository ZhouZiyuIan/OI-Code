# 数位动态规划（数位DP）

## 一、数位动态规划简介

​		在某些题目中，会要求在指定区间范围内，求出满足某种条件的数字的数量、总和等。然而这类区间可能很大如果暴力枚举再依次判断合法性很可能会超时。这个时候我们可以通过借用 $DP$ 的思想，以数位为阶段，在数位上进行递推，这便是数位 $DP$ 。

## 二、数位动态规划基础

### 前缀和思想

​		数位$DP$ 有个通用的套路，就是将求解 **这个区间内的满足条件的值** ，转化为 **区间 $[1,r]$ 满足条件的值 - 区间 $[1,l−1]$ 满足条件的值** 。所以一般数位 $DP$ 的问题都会转化为求从初始点到指定点中满足条件的值，再通过前缀和思想处理后求解答案。

### 通用状态

​		通常情况下，数位 $DP$ 会出现某些状态在不满足条件下仍然能够执行转移。比如对于一个小于 `21` 的数，当十位为 `1` 的情况下，个位可选数值可以超过原数的 `1` ，取值范围便可达 `0~9` 。

​		此类情况非常常见，而为了避免重复计算，一般我们都会提前预处理出通用状态。以上述例子为例，我们可以预处理出每一位数满数值下的数字数量，当然正常情况下并不会如此简单，这就需要根据情况去进行定义了。

### 数位DP基础操作

​		数位 $DP$ 基本都在数位上进行操作，所以大部分情况下我们都需要按照题目将目标区间转化为相应进制（一般为十进制和二进制）。当确认进制后，我们便可以开始执行逐位操作了。然而多数情况下题目会有很多限制条件，所以我们一般都使用记忆化搜索来编写程序，这样会在一定程度上帮助我们更轻松地完成题目。

​		假设现在需要我们求解指定区间内所有数的数位之和，数位限制一般都是高位优先级更高，所以通常情况下我们都是从高位开始处理。我们通过形参 $pos$​ 来表示当前处理的位置，假设目前我们需要处理范围 $[0,4321]$​ ，那么最高位上可能出现的情况有三种：

- 若选择 $0∼3$ 的话，那后面的数字可以任意选择；

- 若选择 $4$ 的话，则后续选择的数字受到限制，比如下一位就不能超过 $3$ 了，否则就超出 $[0,4321]$ 这个区间了；
- 若选择大于 $4$ 的话，后续完成选择的数一定不存在于目标范围。比如以 $5$ 开头的数后续无论你怎么选择，结果也不可能出现在 $[0,4321]$ 这个范围内。

​		因此，我们需要添加一维状态来表示当前选择是否受到限。而在记忆化搜索中，我们一般会添加一个形参 $lim$ 来表示限制情况。其中 $lim$ 为 $0$ 时表示没有限制，否则就需要按要求限制选择。

​		当 $pos=0$ 时，就表示所有数位都选择完毕了，说明已达到递归边界。这时需要返回选择的所有数位和，所以我们需要添加一维状态表示当前选择的数位和。在记忆化搜索中，我们会添加一个形参 $sum$ 来统计当前数位和，方便后续计算。

​		最后由于需要使用记忆化搜索来减少多余的计算，所以需要把当前计算完成的结果储存起来，结合上述变量的定义，我们可以将状态设为 $f[pos][sum][lim]$ 。不过在记忆化搜索下，我们可以将是否受限这一状态通过形参来转移，从而减少空间需求。

​		综上所述，我们可以完成记忆化搜索部分的代码：

```c++
int dfs(int pos, int lim, int sum) {
    //是否完成选择，达到边界
    if (!pos) return sum;    	
    //在不受限制并且已经计算过当前状态的值下，直接返回结果
    if (!lim && ~f[pos][sum]) return f[pos][sum];
    //根据是否受限来控制最大可选值
    int mx = lim ? a[pos] : 9;
    int res = 0;
    //当且仅当最高位到当前位 pos 都选择 a[i] 时后续选择才会受到限制
    //所以可以通过传参时传 lim 按位与 当前位是否为最高位 来得到正确得状态
    for (int i = 0; i <= mx; i ++)
        res = (res + dfs(pos - 1, lim && i == mx, sum + i)) % md;
    //存储不受限制下的答案,方便后续重复使用
    if (!lim) f[pos][sum] = res;
    return res;
}
int fun(int x) {
    int len = 0;
    //因为0有可能是计算结果,所以需要将 f 数组初始化为 -1
    memset(f, -1, sizeof f);
    //将范围有边界按数位拆分,并存储到 a 数组内
    while(x > 0) {
        a[++len] = x % 10;
        x /= 10;
    }
    //从最高位开始执行记忆化搜索,最高位是一定受限的,所以限制项传 1
    return dfs(len, 1, 0);
}
```

​		这里我们可以思考一下，这里为什么状态设置不添加 $lim$ ？

- 如果题目出现多组数据的话，由于 $f$ 数组没有添加状态限制，那么计算其他组数据时就可以直接使用，进一步节省时间；
- 在编写程序中我们发现，当且仅当前面所有位都使用 $a[i]$ 时后续选择才会受到限制，换句话来说如果我们把 $lim$ 记录进状态中，那么真正转移时会用到带 $lim$ 的情况只有一个分支，相比所有选择来看使用率并不算高。并且在多组数据时我们还需要花时间清除掉带 $lim$ 的状态，因为不同数据的限制并不相同，从而浪费时间。

所以没必要在状态上添加 $lim$ ，只需要在形参上传递限制信息即可。

### 数位DP的常用形参

​		通常情况下，数位 $DP$ 往往会把约束设置为形参和动态规划的状态，这里把常用的状态信息做个基础总结，方便在完成数位 $DP$ 的题目时更有方向性地思考：

- $pos$：表示当前枚举的位置，一般从高到低；

- $lim$：表示当前位置的选择是否受到限制；

- $last$：表示上一位填写的值，一般用于相邻数位之间存在条件的题目;

- $lead$：表示是否有 **前导零** ，注意时从最高位到当前位置是不是 **都是前导零** ;

  * 一般情况下一个数是没有前导零，也就是最高位不能为 `0` ，即不会存在 `000123` ，而是 `123`

  - 只有没有前导零的时候，才能计算0的贡献，那么前导零何时跟答案有关？

    * 统计 `0` 的出现次数

    - 相邻数字的差值
    - 以最高位为起点确定的奇偶位

- $sum$：表示前 $pos$ 位的数位和

- $md$：表示整个数前缀取模某个数m的余数

  * 该参数一般会用在：约束中出现了能被m整除

  - 当然也可以拓展为数位和取模的结果

- $sta$：用于状态压缩。对一个集合的数在数位上的出现次数的奇偶性有要求时，其二进制形式就可以表示每个数出现的奇偶性

​		一定要注意的是，数位 $DP$ 的约束条件不只有这些，还需要根据不同的题目进行思考，灵活变通。

